#!/usr/bin/python
# -*- coding: utf-8 -*-



"""
___________________________________________________________
Следующая повторяющаяся последовательность определена для множества натуральных чисел:

n → n/2 (n - четное)
n → 3n + 1 (n - нечетное)

Используя описанное выше правило и начиная с 13, сгенерируется следующая последовательность:

13 → 40 → 20 → 10 → 5 → 16 → 8 → 4 → 2 → 1
Получившаяся последовательность (начиная с 13 и заканчивая 1) содержит 10 элементов. 
Хотя это до сих пор и не доказано (проблема Коллатца (Collatz)), предполагается, 
что все сгенерированные таким образом последовательности оканчиваются на 1.

Какой начальный элемент меньше миллиона генерирует самую длинную последовательность?

Примечание: Следующие за первым элементы последовательности могут быть больше миллиона."""






'''
def f_n_new(old_n):
	# функция вчисляет новый элемент для последовательности 
	if old_n % 2 == 1:
		return 3 * old_n + 1
	else:
		return int(old_n / 2)


def f_len_posl_kollatz(x_in):
	# функция вычисляет длину последовательности коллатза для входного числа 
	k = 1
	while x_in != 1:
		x_in = f_n_new(x_in)
		k += 1 
	return k


max_k = 0 
x_input = 1000000

for i in range(13, x_input):
	len_k = f_len_posl_kollatz(i) 
	if len_k >= max_k:
		max_k = len_k

print(max_k)
'''





def f_collatz_by_requ(nums, len_collatz=1):
	# рекурсивная фкнкция вычисления следующего элемента последовательности коллатза

	if nums == 1:   # крайний случай /выход из рекурсии
		return len_collatz
	elif nums % 2 == 1:
		return f_collatz_by_requ(3*nums + 1, len_collatz+1)   # при n - четном
	else:
		return f_collatz_by_requ(int(nums / 2), len_collatz+1)   # при n - не четном

max_k = 0 
x_input = 1000000

for i in range(13, x_input): 
	len_col = f_collatz_by_requ(i)
	# обновление максимальной длины последовательности и начального числа для нее
	if len_col > max_k:   
		i_max, max_k = i, len_col

print(i_max, max_k)   #i_max = 837799, max_k = 525


